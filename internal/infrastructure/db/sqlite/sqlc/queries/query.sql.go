// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
)

const createSwap = `-- name: CreateSwap :exec
INSERT INTO swap (
  id, amount, timestamp, to_currency, from_currency, status, invoice, funding_tx_id, redeem_tx_id, vhtlc_id
) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
`

type CreateSwapParams struct {
	ID           string
	Amount       int64
	Timestamp    int64
	ToCurrency   string
	FromCurrency string
	Status       int64
	Invoice      string
	FundingTxID  string
	RedeemTxID   string
	VhtlcID      string
}

// Swap queries
func (q *Queries) CreateSwap(ctx context.Context, arg CreateSwapParams) error {
	_, err := q.db.ExecContext(ctx, createSwap,
		arg.ID,
		arg.Amount,
		arg.Timestamp,
		arg.ToCurrency,
		arg.FromCurrency,
		arg.Status,
		arg.Invoice,
		arg.FundingTxID,
		arg.RedeemTxID,
		arg.VhtlcID,
	)
	return err
}

const deleteSettings = `-- name: DeleteSettings :exec
DELETE FROM settings
`

func (q *Queries) DeleteSettings(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSettings)
	return err
}

const deleteSubscribedScript = `-- name: DeleteSubscribedScript :exec
DELETE FROM subscribed_script WHERE script = ?
`

func (q *Queries) DeleteSubscribedScript(ctx context.Context, script string) error {
	_, err := q.db.ExecContext(ctx, deleteSubscribedScript, script)
	return err
}

const deleteVtxoRollover = `-- name: DeleteVtxoRollover :exec
DELETE FROM vtxo_rollover WHERE address = ?
`

func (q *Queries) DeleteVtxoRollover(ctx context.Context, address string) error {
	_, err := q.db.ExecContext(ctx, deleteVtxoRollover, address)
	return err
}

const getSettings = `-- name: GetSettings :one
SELECT id, api_root, server_url, esplora_url, currency, event_server, full_node, ln_url, unit FROM settings WHERE id = 1
`

func (q *Queries) GetSettings(ctx context.Context) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSettings)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.ApiRoot,
		&i.ServerUrl,
		&i.EsploraUrl,
		&i.Currency,
		&i.EventServer,
		&i.FullNode,
		&i.LnUrl,
		&i.Unit,
	)
	return i, err
}

const getSubscribedScript = `-- name: GetSubscribedScript :one
SELECT script FROM subscribed_script WHERE script = ?
`

func (q *Queries) GetSubscribedScript(ctx context.Context, script string) (string, error) {
	row := q.db.QueryRowContext(ctx, getSubscribedScript, script)
	err := row.Scan(&script)
	return script, err
}

const getSwap = `-- name: GetSwap :one
SELECT  swap.id, swap.amount, swap.timestamp, swap.to_currency, swap.from_currency, swap.status, swap.invoice, swap.funding_tx_id, swap.redeem_tx_id, swap.vhtlc_id,
        vhtlc.preimage_hash, vhtlc.sender, vhtlc.receiver, vhtlc.server, vhtlc.refund_locktime, vhtlc.unilateral_claim_delay_type, vhtlc.unilateral_claim_delay_value, vhtlc.unilateral_refund_delay_type, vhtlc.unilateral_refund_delay_value, vhtlc.unilateral_refund_without_receiver_delay_type, vhtlc.unilateral_refund_without_receiver_delay_value
FROM swap
  LEFT JOIN vhtlc ON swap.vhtlc_id = vhtlc.preimage_hash
WHERE id = ?
`

type GetSwapRow struct {
	Swap  Swap
	Vhtlc Vhtlc
}

func (q *Queries) GetSwap(ctx context.Context, id string) (GetSwapRow, error) {
	row := q.db.QueryRowContext(ctx, getSwap, id)
	var i GetSwapRow
	err := row.Scan(
		&i.Swap.ID,
		&i.Swap.Amount,
		&i.Swap.Timestamp,
		&i.Swap.ToCurrency,
		&i.Swap.FromCurrency,
		&i.Swap.Status,
		&i.Swap.Invoice,
		&i.Swap.FundingTxID,
		&i.Swap.RedeemTxID,
		&i.Swap.VhtlcID,
		&i.Vhtlc.PreimageHash,
		&i.Vhtlc.Sender,
		&i.Vhtlc.Receiver,
		&i.Vhtlc.Server,
		&i.Vhtlc.RefundLocktime,
		&i.Vhtlc.UnilateralClaimDelayType,
		&i.Vhtlc.UnilateralClaimDelayValue,
		&i.Vhtlc.UnilateralRefundDelayType,
		&i.Vhtlc.UnilateralRefundDelayValue,
		&i.Vhtlc.UnilateralRefundWithoutReceiverDelayType,
		&i.Vhtlc.UnilateralRefundWithoutReceiverDelayValue,
	)
	return i, err
}

const getVHTLC = `-- name: GetVHTLC :one
SELECT preimage_hash, sender, receiver, server, refund_locktime, unilateral_claim_delay_type, unilateral_claim_delay_value, unilateral_refund_delay_type, unilateral_refund_delay_value, unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value FROM vhtlc WHERE preimage_hash = ?
`

func (q *Queries) GetVHTLC(ctx context.Context, preimageHash string) (Vhtlc, error) {
	row := q.db.QueryRowContext(ctx, getVHTLC, preimageHash)
	var i Vhtlc
	err := row.Scan(
		&i.PreimageHash,
		&i.Sender,
		&i.Receiver,
		&i.Server,
		&i.RefundLocktime,
		&i.UnilateralClaimDelayType,
		&i.UnilateralClaimDelayValue,
		&i.UnilateralRefundDelayType,
		&i.UnilateralRefundDelayValue,
		&i.UnilateralRefundWithoutReceiverDelayType,
		&i.UnilateralRefundWithoutReceiverDelayValue,
	)
	return i, err
}

const getVtxoRollover = `-- name: GetVtxoRollover :one
SELECT address, taproot_tree, destination_address FROM vtxo_rollover WHERE address = ?
`

func (q *Queries) GetVtxoRollover(ctx context.Context, address string) (VtxoRollover, error) {
	row := q.db.QueryRowContext(ctx, getVtxoRollover, address)
	var i VtxoRollover
	err := row.Scan(&i.Address, &i.TaprootTree, &i.DestinationAddress)
	return i, err
}

const insertSubscribedScript = `-- name: InsertSubscribedScript :exec
INSERT INTO subscribed_script (script)
VALUES (?)
`

// SubscribedScript queries
func (q *Queries) InsertSubscribedScript(ctx context.Context, script string) error {
	_, err := q.db.ExecContext(ctx, insertSubscribedScript, script)
	return err
}

const insertVHTLC = `-- name: InsertVHTLC :exec
INSERT INTO vhtlc (
    preimage_hash, sender, receiver, server, refund_locktime,
    unilateral_claim_delay_type, unilateral_claim_delay_value,
    unilateral_refund_delay_type, unilateral_refund_delay_value,
    unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertVHTLCParams struct {
	PreimageHash                              string
	Sender                                    string
	Receiver                                  string
	Server                                    string
	RefundLocktime                            int64
	UnilateralClaimDelayType                  int64
	UnilateralClaimDelayValue                 int64
	UnilateralRefundDelayType                 int64
	UnilateralRefundDelayValue                int64
	UnilateralRefundWithoutReceiverDelayType  int64
	UnilateralRefundWithoutReceiverDelayValue int64
}

// VHTLC queries
func (q *Queries) InsertVHTLC(ctx context.Context, arg InsertVHTLCParams) error {
	_, err := q.db.ExecContext(ctx, insertVHTLC,
		arg.PreimageHash,
		arg.Sender,
		arg.Receiver,
		arg.Server,
		arg.RefundLocktime,
		arg.UnilateralClaimDelayType,
		arg.UnilateralClaimDelayValue,
		arg.UnilateralRefundDelayType,
		arg.UnilateralRefundDelayValue,
		arg.UnilateralRefundWithoutReceiverDelayType,
		arg.UnilateralRefundWithoutReceiverDelayValue,
	)
	return err
}

const listSubscribedScript = `-- name: ListSubscribedScript :many
SELECT script FROM subscribed_script
`

func (q *Queries) ListSubscribedScript(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listSubscribedScript)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var script string
		if err := rows.Scan(&script); err != nil {
			return nil, err
		}
		items = append(items, script)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSwaps = `-- name: ListSwaps :many
SELECT  swap.id, swap.amount, swap.timestamp, swap.to_currency, swap.from_currency, swap.status, swap.invoice, swap.funding_tx_id, swap.redeem_tx_id, swap.vhtlc_id, vhtlc.preimage_hash, vhtlc.sender, vhtlc.receiver, vhtlc.server, vhtlc.refund_locktime, vhtlc.unilateral_claim_delay_type, vhtlc.unilateral_claim_delay_value, vhtlc.unilateral_refund_delay_type, vhtlc.unilateral_refund_delay_value, vhtlc.unilateral_refund_without_receiver_delay_type, vhtlc.unilateral_refund_without_receiver_delay_value
FROM swap
  LEFT JOIN vhtlc ON swap.vhtlc_id = vhtlc.preimage_hash
`

type ListSwapsRow struct {
	Swap  Swap
	Vhtlc Vhtlc
}

func (q *Queries) ListSwaps(ctx context.Context) ([]ListSwapsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSwaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSwapsRow
	for rows.Next() {
		var i ListSwapsRow
		if err := rows.Scan(
			&i.Swap.ID,
			&i.Swap.Amount,
			&i.Swap.Timestamp,
			&i.Swap.ToCurrency,
			&i.Swap.FromCurrency,
			&i.Swap.Status,
			&i.Swap.Invoice,
			&i.Swap.FundingTxID,
			&i.Swap.RedeemTxID,
			&i.Swap.VhtlcID,
			&i.Vhtlc.PreimageHash,
			&i.Vhtlc.Sender,
			&i.Vhtlc.Receiver,
			&i.Vhtlc.Server,
			&i.Vhtlc.RefundLocktime,
			&i.Vhtlc.UnilateralClaimDelayType,
			&i.Vhtlc.UnilateralClaimDelayValue,
			&i.Vhtlc.UnilateralRefundDelayType,
			&i.Vhtlc.UnilateralRefundDelayValue,
			&i.Vhtlc.UnilateralRefundWithoutReceiverDelayType,
			&i.Vhtlc.UnilateralRefundWithoutReceiverDelayValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVHTLC = `-- name: ListVHTLC :many
SELECT preimage_hash, sender, receiver, server, refund_locktime, unilateral_claim_delay_type, unilateral_claim_delay_value, unilateral_refund_delay_type, unilateral_refund_delay_value, unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value FROM vhtlc
`

func (q *Queries) ListVHTLC(ctx context.Context) ([]Vhtlc, error) {
	rows, err := q.db.QueryContext(ctx, listVHTLC)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vhtlc
	for rows.Next() {
		var i Vhtlc
		if err := rows.Scan(
			&i.PreimageHash,
			&i.Sender,
			&i.Receiver,
			&i.Server,
			&i.RefundLocktime,
			&i.UnilateralClaimDelayType,
			&i.UnilateralClaimDelayValue,
			&i.UnilateralRefundDelayType,
			&i.UnilateralRefundDelayValue,
			&i.UnilateralRefundWithoutReceiverDelayType,
			&i.UnilateralRefundWithoutReceiverDelayValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVtxoRollover = `-- name: ListVtxoRollover :many
SELECT address, taproot_tree, destination_address FROM vtxo_rollover
`

func (q *Queries) ListVtxoRollover(ctx context.Context) ([]VtxoRollover, error) {
	rows, err := q.db.QueryContext(ctx, listVtxoRollover)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoRollover
	for rows.Next() {
		var i VtxoRollover
		if err := rows.Scan(&i.Address, &i.TaprootTree, &i.DestinationAddress); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSettings = `-- name: UpsertSettings :exec
INSERT INTO settings (id, api_root, server_url, esplora_url, currency, event_server, full_node, ln_url, unit)
VALUES (1, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    api_root = excluded.api_root,
    server_url = excluded.server_url,
    esplora_url = excluded.esplora_url,
    currency = excluded.currency,
    event_server = excluded.event_server,
    full_node = excluded.full_node,
    ln_url = excluded.ln_url,
    unit = excluded.unit
`

type UpsertSettingsParams struct {
	ApiRoot     string
	ServerUrl   string
	EsploraUrl  sql.NullString
	Currency    string
	EventServer string
	FullNode    string
	LnUrl       sql.NullString
	Unit        string
}

// Settings queries
func (q *Queries) UpsertSettings(ctx context.Context, arg UpsertSettingsParams) error {
	_, err := q.db.ExecContext(ctx, upsertSettings,
		arg.ApiRoot,
		arg.ServerUrl,
		arg.EsploraUrl,
		arg.Currency,
		arg.EventServer,
		arg.FullNode,
		arg.LnUrl,
		arg.Unit,
	)
	return err
}

const upsertVtxoRollover = `-- name: UpsertVtxoRollover :exec
INSERT INTO vtxo_rollover (address, taproot_tree, destination_address) VALUES (?, ?, ?)
ON CONFLICT(address) DO UPDATE SET
    taproot_tree = excluded.taproot_tree,
    destination_address = excluded.destination_address
`

type UpsertVtxoRolloverParams struct {
	Address            string
	TaprootTree        string
	DestinationAddress string
}

// VtxoRollover queries
func (q *Queries) UpsertVtxoRollover(ctx context.Context, arg UpsertVtxoRolloverParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxoRollover, arg.Address, arg.TaprootTree, arg.DestinationAddress)
	return err
}
