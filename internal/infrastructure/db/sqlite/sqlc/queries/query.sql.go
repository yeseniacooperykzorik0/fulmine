// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
)

const deleteSettings = `-- name: DeleteSettings :exec
DELETE FROM settings
`

func (q *Queries) DeleteSettings(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSettings)
	return err
}

const deleteVHTLC = `-- name: DeleteVHTLC :exec
DELETE FROM vhtlc WHERE preimage_hash = ?
`

func (q *Queries) DeleteVHTLC(ctx context.Context, preimageHash string) error {
	_, err := q.db.ExecContext(ctx, deleteVHTLC, preimageHash)
	return err
}

const deleteVtxoRollover = `-- name: DeleteVtxoRollover :exec
DELETE FROM vtxo_rollover WHERE address = ?
`

func (q *Queries) DeleteVtxoRollover(ctx context.Context, address string) error {
	_, err := q.db.ExecContext(ctx, deleteVtxoRollover, address)
	return err
}

const getSettings = `-- name: GetSettings :one
SELECT api_root, server_url, esplora_url, currency, event_server, full_node, ln_url, unit FROM settings WHERE id = 1
`

type GetSettingsRow struct {
	ApiRoot     string
	ServerUrl   string
	EsploraUrl  sql.NullString
	Currency    string
	EventServer string
	FullNode    string
	LnUrl       sql.NullString
	Unit        string
}

func (q *Queries) GetSettings(ctx context.Context) (GetSettingsRow, error) {
	row := q.db.QueryRowContext(ctx, getSettings)
	var i GetSettingsRow
	err := row.Scan(
		&i.ApiRoot,
		&i.ServerUrl,
		&i.EsploraUrl,
		&i.Currency,
		&i.EventServer,
		&i.FullNode,
		&i.LnUrl,
		&i.Unit,
	)
	return i, err
}

const getVHTLC = `-- name: GetVHTLC :one
SELECT preimage_hash, sender, receiver, server, refund_locktime, unilateral_claim_delay_type, unilateral_claim_delay_value, unilateral_refund_delay_type, unilateral_refund_delay_value, unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value
FROM vhtlc WHERE preimage_hash = ?
`

func (q *Queries) GetVHTLC(ctx context.Context, preimageHash string) (Vhtlc, error) {
	row := q.db.QueryRowContext(ctx, getVHTLC, preimageHash)
	var i Vhtlc
	err := row.Scan(
		&i.PreimageHash,
		&i.Sender,
		&i.Receiver,
		&i.Server,
		&i.RefundLocktime,
		&i.UnilateralClaimDelayType,
		&i.UnilateralClaimDelayValue,
		&i.UnilateralRefundDelayType,
		&i.UnilateralRefundDelayValue,
		&i.UnilateralRefundWithoutReceiverDelayType,
		&i.UnilateralRefundWithoutReceiverDelayValue,
	)
	return i, err
}

const getVtxoRollover = `-- name: GetVtxoRollover :one
SELECT address, taproot_tree, destination_address FROM vtxo_rollover WHERE address = ?
`

func (q *Queries) GetVtxoRollover(ctx context.Context, address string) (VtxoRollover, error) {
	row := q.db.QueryRowContext(ctx, getVtxoRollover, address)
	var i VtxoRollover
	err := row.Scan(&i.Address, &i.TaprootTree, &i.DestinationAddress)
	return i, err
}

const insertVHTLC = `-- name: InsertVHTLC :exec
INSERT INTO vhtlc (
    preimage_hash, sender, receiver, server, refund_locktime,
    unilateral_claim_delay_type, unilateral_claim_delay_value,
    unilateral_refund_delay_type, unilateral_refund_delay_value,
    unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(preimage_hash) DO UPDATE SET
    sender = excluded.sender,
    receiver = excluded.receiver,
    server = excluded.server,
    refund_locktime = excluded.refund_locktime,
    unilateral_claim_delay_type = excluded.unilateral_claim_delay_type,
    unilateral_claim_delay_value = excluded.unilateral_claim_delay_value,
    unilateral_refund_delay_type = excluded.unilateral_refund_delay_type,
    unilateral_refund_delay_value = excluded.unilateral_refund_delay_value,
    unilateral_refund_without_receiver_delay_type = excluded.unilateral_refund_without_receiver_delay_type,
    unilateral_refund_without_receiver_delay_value = excluded.unilateral_refund_without_receiver_delay_value
`

type InsertVHTLCParams struct {
	PreimageHash                              string
	Sender                                    string
	Receiver                                  string
	Server                                    string
	RefundLocktime                            int64
	UnilateralClaimDelayType                  int64
	UnilateralClaimDelayValue                 int64
	UnilateralRefundDelayType                 int64
	UnilateralRefundDelayValue                int64
	UnilateralRefundWithoutReceiverDelayType  int64
	UnilateralRefundWithoutReceiverDelayValue int64
}

// VHTLC queries
func (q *Queries) InsertVHTLC(ctx context.Context, arg InsertVHTLCParams) error {
	_, err := q.db.ExecContext(ctx, insertVHTLC,
		arg.PreimageHash,
		arg.Sender,
		arg.Receiver,
		arg.Server,
		arg.RefundLocktime,
		arg.UnilateralClaimDelayType,
		arg.UnilateralClaimDelayValue,
		arg.UnilateralRefundDelayType,
		arg.UnilateralRefundDelayValue,
		arg.UnilateralRefundWithoutReceiverDelayType,
		arg.UnilateralRefundWithoutReceiverDelayValue,
	)
	return err
}

const listVHTLC = `-- name: ListVHTLC :many
SELECT preimage_hash, sender, receiver, server, refund_locktime, unilateral_claim_delay_type, unilateral_claim_delay_value, unilateral_refund_delay_type, unilateral_refund_delay_value, unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value
FROM vhtlc
`

func (q *Queries) ListVHTLC(ctx context.Context) ([]Vhtlc, error) {
	rows, err := q.db.QueryContext(ctx, listVHTLC)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vhtlc
	for rows.Next() {
		var i Vhtlc
		if err := rows.Scan(
			&i.PreimageHash,
			&i.Sender,
			&i.Receiver,
			&i.Server,
			&i.RefundLocktime,
			&i.UnilateralClaimDelayType,
			&i.UnilateralClaimDelayValue,
			&i.UnilateralRefundDelayType,
			&i.UnilateralRefundDelayValue,
			&i.UnilateralRefundWithoutReceiverDelayType,
			&i.UnilateralRefundWithoutReceiverDelayValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVtxoRollover = `-- name: ListVtxoRollover :many
SELECT address, taproot_tree, destination_address FROM vtxo_rollover
`

func (q *Queries) ListVtxoRollover(ctx context.Context) ([]VtxoRollover, error) {
	rows, err := q.db.QueryContext(ctx, listVtxoRollover)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoRollover
	for rows.Next() {
		var i VtxoRollover
		if err := rows.Scan(&i.Address, &i.TaprootTree, &i.DestinationAddress); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSettings = `-- name: UpsertSettings :exec
INSERT INTO settings (id, api_root, server_url, esplora_url, currency, event_server, full_node, ln_url, unit)
VALUES (1, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    api_root = excluded.api_root,
    server_url = excluded.server_url,
    esplora_url = excluded.esplora_url,
    currency = excluded.currency,
    event_server = excluded.event_server,
    full_node = excluded.full_node,
    ln_url = excluded.ln_url,
    unit = excluded.unit
`

type UpsertSettingsParams struct {
	ApiRoot     string
	ServerUrl   string
	EsploraUrl  sql.NullString
	Currency    string
	EventServer string
	FullNode    string
	LnUrl       sql.NullString
	Unit        string
}

// Settings queries
func (q *Queries) UpsertSettings(ctx context.Context, arg UpsertSettingsParams) error {
	_, err := q.db.ExecContext(ctx, upsertSettings,
		arg.ApiRoot,
		arg.ServerUrl,
		arg.EsploraUrl,
		arg.Currency,
		arg.EventServer,
		arg.FullNode,
		arg.LnUrl,
		arg.Unit,
	)
	return err
}

const upsertVtxoRollover = `-- name: UpsertVtxoRollover :exec
INSERT INTO vtxo_rollover (address, taproot_tree, destination_address) VALUES (?, ?, ?)
ON CONFLICT(address) DO UPDATE SET
    taproot_tree = excluded.taproot_tree,
    destination_address = excluded.destination_address
`

type UpsertVtxoRolloverParams struct {
	Address            string
	TaprootTree        string
	DestinationAddress string
}

// VtxoRollover queries
func (q *Queries) UpsertVtxoRollover(ctx context.Context, arg UpsertVtxoRolloverParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxoRollover, arg.Address, arg.TaprootTree, arg.DestinationAddress)
	return err
}
